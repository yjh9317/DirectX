#pragma once
#include "CRes.h"

#include <DirectXTex/DirectXTex.h> //여러 포맷(확장자)들을 이미지로 압축해제를 도와주는 라이브러리

#ifdef _DEBUG
#pragma comment(lib, "DirectXTex/DirectXTex_debug")
#else
#pragma comment(lib, "DirectXTex/DirectXTex")
#endif


class CTexture :
    public CRes
{
private:
    ScratchImage                        m_Image;    // 파일로부터 로딩한 텍스쳐 데이터의 시스템 메모리 관리
    ComPtr<ID3D11Texture2D>             m_pTex2D;   // GPU 에 로딩된 텍스쳐 데이터를 관리하는 인터페이스

    // 하나의 텍스쳐로 용도에 맞게 View를 설정
    // SRV,UAV,RTV 는 서로 호환이 되지만 DSV는 호환성이 없다. 조합할 때 DSV는 따로 써야한다, 같이쓰면 실패

    ComPtr<ID3D11ShaderResourceView>    m_pSRV;     // Texture2D 를 ShaderResource 용도로 전달하는 중간 매개체
    ComPtr<ID3D11UnorderedAccessView>   m_pUAV;     // Texture2D를 RwTexture 용도로 전달하는 View
    ComPtr<ID3D11RenderTargetView>      m_pRTV;     // Texture2D 를 RenderTarget 용도로 전달
    ComPtr<ID3D11DepthStencilView>      m_pDSV;     // Texture2D 를 DepthStencil 용도로 전달 
   
    D3D11_TEXTURE2D_DESC                m_tDesc;    // Load함수 안의 CreateShaderResourceView함수로 Desc가 채워졌고 거기서 가져와서 저장.

protected:
    virtual int Load(const wstring& _strFilePath);
    void Create(UINT _iWidth, UINT _iHeight,DXGI_FORMAT _format,UINT _flag); // 가로,세로,픽셀정보,플래그 .자체적으로 이미지Create
    void Create(ComPtr<ID3D11Texture2D> _pTex2D);

public:
    // ScartchImage에서도 가져올 수 있지만 gpu메모리에 다이렉트로 텍스쳐를 만들고 사용하면 없을수도 있음
    float Width() { return (float)m_tDesc.Width; }
    float Height() { return (float)m_tDesc.Height; }

    ComPtr<ID3D11ShaderResourceView> GetSRV() { return m_pSRV; }
    ComPtr<ID3D11UnorderedAccessView> GetUAV() { return m_pUAV; }
    ComPtr<ID3D11RenderTargetView> GetRTV() { return m_pRTV; }
    ComPtr<ID3D11DepthStencilView> GetDSV() { return m_pDSV; }
    
public:
    // PIPELINE_STAGE
    void UpdateData(UINT _PipelineStage, int _iRegisterNum);

    void UpdateData_CS(int _iRegisterNum); //Compute Shader에서 레지스터에 바인딩할 함수
    static void Clear(int _iRegisterNum);
    static void ClearCS(int _iRegisterNum);

public:
    CTexture();
    ~CTexture();

    friend class CResMgr;
};

